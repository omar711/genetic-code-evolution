%% GCDISTANCE calulcates pairwise distances between the genetic codes
% using the specified distance measure.
% The options for this measure are as follows:
%   'disagreementCount'     - the number of times that codes disagree over
%   the amino acid that a given codon codes for.
%
%   'disagreementCountStarts- same as above but counts the differences in
%   start codon assignments.
%
%   'mutationCostPam10'     - uses the function mutationCost.m to get a
%   distance measure.  This uses the pam10 matrix.
%
function [gcDist gcNames] = gcDistance( distFuncName )
    [gcIndices gcCount] = lookupTable( 'gcIndices' );
    %gcIndices = [gcIndices; 99]; gcCount = gcCount + 1;
    codons = lookupTable( 'codons' );
    distMeasure = str2func( distFuncName );

    gcDist = zeros( gcCount );
    gcNames = { gcCount };
    for i = 1 : gcCount
        ci = gcIndices(i);
        for j = 1 : gcCount            
            cj = gcIndices(j);
            gcDist(i,j) = distMeasure( ci, cj, codons );
        end
        code = getgeneticcode( ci );
        gcNames{i} = code.Name;
    end

%% Adds some custom genetic codes to the standard ones.
function gc = getgeneticcode( id )
    if id == 99
        gc = generalGeneticCode;
    else
        gc = geneticcode( id );
    end

%% Mutation cost with pam 10 matrix
function dist = mutationCostPam10( fromID, toID, codons )
    dist = mutationCostPam( fromID, toID, codons, 10 );
    
%% Mutation cost
% This is the sum of differences between the mutation cost of each codon
% when translated in each code.
function dist = mutationCostPam( fromID, toID, codons, pamNum, includeStarts )
    dist = 0;
    fromCode = getgeneticcode( fromID );
    toCode = getgeneticcode( toID );
    for c = 1 : length( codons )
        codon = codons{c};
        fromCost = mutationCost( codon, fromCode, pamNum );
        toCost = mutationCost( codon, toCode, pamNum );
        dist = dist + abs( fromCost - toCost );
    end
    if nargin > 4
        % handle starts
    end
   
%% Disagreement Count (includes start codons)
function dist = disagreementCountStarts( fromID, toID, codons )
    dist = disagreementCount( fromID, toID, codons, 'includeStarts' );
    
%% Disagreement Count
% This measures the number of times that the genetic
% codes disagree on the amino acid output for eah codon.
%
% includeStarts is optional and if present will include
% the start codons in the distance measure.
function dist = disagreementCount( fromID, toID, codons, includeStarts )
    fromCode = getgeneticcode( fromID );
    toCode = getgeneticcode( toID );
    dist = 0;
    for i = 1 : length( codons )
        codon = char( codons(i) );
        if ( fromCode.(codon) ~= toCode.(codon) )
            dist = dist + 1;
        end
    end
    % include differences in start and stop codons if specified
    if ( nargin > 3 )
        dist = dist + startDistance( fromCode.Starts, toCode.Starts );
    end
   
    
%% Find the distance between the given start codon lists.
% Differences are considered to be more important than extra start codons.
% The distance added per mismatch is set by the weighting variable.
% This scales the influence of start codons relative to any other measure.
% A further scaling is added at the end, where the difference in lengths
% between start codon lists is condsidered.  This value is multiplied by
% 0.25 * weighting.
function dist = startDistance( fromStarts, toStarts )
    weighting = 1;
    dist = 0;
    % make sure that from is the shorter of the two lists
    if length( toStarts ) < length( fromStarts )
        temp = toStarts;
        toStarts = fromStarts;
        fromStarts = temp;
    end
    for i = 1 : length( fromStarts )
        fromStart = fromStarts(i);
        if ( ~listContains( toStarts, fromStart ) )
            dist = dist + weighting;
        end
    end
    lengthDifference = abs( length( fromStarts ) - length( toStarts ) );
    dist = dist + ( weighting * 0.25 * lengthDifference );
    
%% Search the array of codons, return true if it contains the given codon
function contained = listContains( list, codon )
    contained = false;
    for i = 1 : length( list )
        if ( strcmpi( list{i}, codon ) == 0 )
            contained = true;
        end
    end
    
%% The 'General Genetic Code' generated by the OneR classifier in WEKA
function ggc = generalGeneticCode
    ggc.Name = 'General';
	ggc.AAA	= 'K';
	ggc.AAG	= 'K';
	ggc.AAC	= 'N';
	ggc.AAT	= 'N';
    ggc.AGA	= 'R';
	ggc.AGG	= 'R';
	ggc.AGC	= 'S';
	ggc.AGT	= 'S';
	ggc.ACA	= 'T';
	ggc.ACG	= 'T';
	ggc.ACC	= 'T';
	ggc.ACT	= 'T';
	ggc.ATA	= 'I';
	ggc.ATG	= 'M';
	ggc.ATC	= 'I';
	ggc.ATT	= 'I';
	ggc.GAA	= 'E';
	ggc.GAG	= 'E';
	ggc.GAC	= 'D';
	ggc.GAT	= 'D';
	ggc.GGA	= 'G';
	ggc.GGG	= 'G';
	ggc.GGC	= 'G';
	ggc.GGT	= 'G';
	ggc.GCA	= 'A';
	ggc.GCG	= 'A';
	ggc.GCC	= 'A';
	ggc.GCT	= 'A';
	ggc.GTA	= 'V';
	ggc.GTG	= 'V';
	ggc.GTC	= 'V';
	ggc.GTT	= 'V';
	ggc.CAA	= 'Q';
	ggc.CAG	= 'Q';
	ggc.CAC	= 'H';
	ggc.CAT	= 'H';
	ggc.CGA	= 'R';
	ggc.CGG	= 'R';
	ggc.CGC	= 'R';
	ggc.CGT	= 'R';
	ggc.CCA	= 'P';
	ggc.CCG	= 'P';
	ggc.CCC	= 'P';
	ggc.CCT	= 'P';
	ggc.CTA	= 'L';
	ggc.CTG	= 'L';
	ggc.CTC	= 'L';
	ggc.CTT	= 'L';
	ggc.TAA	= '*';
	ggc.TAG	= '*';
	ggc.TAC	= 'Y';
	ggc.TAT	= 'Y';
	ggc.TGA	= '*';
	ggc.TGG	= 'W';
	ggc.TGC	= 'C';
	ggc.TGT	= 'C';
	ggc.TCA	= 'S';
	ggc.TCG	= 'S';
	ggc.TCC	= 'S';
	ggc.TCT	= 'S';
	ggc.TTA	= 'L';
	ggc.TTG	= 'L';
	ggc.TTC	= 'F';
	ggc.TTT	= 'F';
    ggc.Starts = {};
    